#!/usr/bin/env python3

import argparse
import collections as cl
import pysam   # <-- NEW (pip/conda install pysam)

def to_ranges(nums):
    if not nums:
        return []
    nums = sorted(nums)
    ranges = []
    start = end = nums[0]
    for n in nums[1:]:
        if n == end + 1:
            end = n
        elif n > end + 1:
            ranges.append((start, end))
            start = end = n
    ranges.append((start, end))
    return ranges


def overlaploci(varts, regions):
    lvars = 2 * len(varts)
    allcoordis = [x for y in varts + regions for x in y[:2]]
    allcoordis_sortindex = sorted(range(len(allcoordis)), key=lambda x: allcoordis[x])

    region_ranges = [[] for _ in regions]
    curr_regions = set()
    curr_varts = set()

    for x in allcoordis_sortindex:
        if x >= lvars:
            r_idx = (x - lvars) // 2
            if x % 2 == 0:
                region_ranges[r_idx] = list(curr_varts)
                curr_regions.add(r_idx)
            else:
                curr_regions.discard(r_idx)
        else:
            v_idx = x // 2
            if x % 2 == 0:
                for r in curr_regions:
                    region_ranges[r].append(v_idx)
                curr_varts.add(v_idx)
            else:
                curr_varts.discard(v_idx)

    for i, region_var_idxs in enumerate(region_ranges):
        if not region_var_idxs:
            region_ranges[i] = []
            continue

        line_indices = [varts[v_i][2] for v_i in region_var_idxs]
        ranges = to_ranges(line_indices)

        lindex_to_vidx = {varts[v_i][2]: v_i for v_i in region_var_idxs}

        final_byte_ranges = []
        for r_start, r_end in ranges:
            v_start_idx = lindex_to_vidx[r_start]
            v_end_idx = lindex_to_vidx[r_end]
            start_byte = varts[v_start_idx][3]  # now: virtual offset
            end_byte   = varts[v_end_idx][4]    # now: virtual offset
            final_byte_ranges.append((start_byte, end_byte))

        region_ranges[i] = final_byte_ranges

    return region_ranges


def sample_key_from_name(name: str) -> str:
    parts = name.split("_")
    if len(parts) >= 3:
        return "_".join(parts[1:3])
    return ""


def load_regions(regionfile: str, samplename: str):
    by_contig = cl.defaultdict(list)

    with open(regionfile, "r") as f:
        for line in f:
            line = line.rstrip("\n")
            if not line or line.startswith("#"):
                continue
            parts = line.split("\t")
            if len(parts) < 7:
                continue

            name = parts[0].lstrip(">")
            contig = parts[1]
            strd = parts[2]
            start = int(parts[3])
            end = int(parts[4])
            left = int(parts[5])
            right = int(parts[6])
            if sample_key_from_name(name) != samplename:
                continue

            valid = (left != -1 and right != -1)
            sub_start = start + left if valid else -1
            sub_end = end - right if valid else -1
            if valid and sub_start >= sub_end:
                valid = False
                sub_start = sub_end = -1
            by_contig[contig].append({
                "name": name,
                "contig": contig,
                "strd": strd,
                "start": start,
                "end": end,
                "left": left,
                "right": right,
                "valid": valid,
                "sub_start": sub_start,
                "sub_end": sub_end,
            })

    return by_contig


def vcfindex(inputfile, regionfile, output, samplename):
    regions_by_contig = load_regions(regionfile, samplename)
    if not regions_by_contig:
        print(f"Error: sample {samplename} not found in region TSV (or no parsable rows).")
        return

    contigs_wanted = set(regions_by_contig.keys())

    vcfcoordi = cl.defaultdict(list)

    # IMPORTANT: BGZFile for virtual offsets
    with pysam.BGZFile(inputfile, mode="rb") as f:
        lindex = 0
        while True:
            voff = f.tell()          # <-- virtual offset (seekable)
            line = f.readline()
            if not line:
                break
            vend = f.tell()          # <-- end virtual offset (seekable)

            line_str = line.decode(errors="replace")
            if line_str.startswith("#"):
                continue

            cols = line_str.split("\t")
            if len(cols) < 8:
                lindex += 1
                continue

            info_field = cols[7]
            region_strs = [x for x in info_field.split(";") if x.startswith("QRY_REGION=")]
            if not region_strs:
                lindex += 1
                continue

            region = region_strs[0][len("QRY_REGION="):]
            if ":" not in region or "-" not in region:
                lindex += 1
                continue

            contig, coord_str = region.split(":", 1)
            if contig not in contigs_wanted:
                lindex += 1
                continue

            try:
                s_str, e_str = coord_str.split("-", 1)
                start = int(s_str)
                end = int(e_str)
            except ValueError:
                lindex += 1
                continue

            # store virtual offsets
            vcfcoordi[contig].append([start, end, lindex, voff, vend])
            lindex += 1

    with open(output, "w") as w:
        for contig, records in regions_by_contig.items():
            varts = vcfcoordi.get(contig, [])

            valid_subregions = []
            valid_pos = []
            for rec in records:
                if rec["valid"]:
                    valid_pos.append(len(valid_subregions))
                    valid_subregions.append([rec["sub_start"], rec["sub_end"]])
                else:
                    valid_pos.append(-1)

            region_ranges = overlaploci(varts, valid_subregions) if valid_subregions else []

            for i, rec in enumerate(records):
                pos = valid_pos[i]
                if pos == -1:
                    result = ""
                else:
                    ranges = region_ranges[pos] if pos < len(region_ranges) else []
                    result = ";".join([f"{a}_{b}" for a, b in ranges]) if ranges else ""

                w.write(
                    f"{rec['name']}\t{rec['contig']}\t{rec['strd']}\t{rec['start']}\t{rec['end']}\t{rec['left']}\t{rec['right']}\t0\t{result}\n"
                )


def main(args):
    vcfindex(args.input, args.region, args.output, args.sample)


def run():
    parser = argparse.ArgumentParser(description="Index VCF byte ranges per (sub)region from first-script output.")
    parser.add_argument("-i", "--input",  dest="input",  type=str, required=True, help="input .vcf.gz (BGZF/bgzip)")
    parser.add_argument("-r", "--region", dest="region", type=str, required=True, help="region TSV from first script")
    parser.add_argument("-o", "--output", dest="output", type=str, required=True, help="output TSV")
    parser.add_argument("-s", "--sample", dest="sample", type=str, required=True, help="sample name key (parts[1:3])")
    parser.set_defaults(func=main)
    args = parser.parse_args()
    args.func(args)

if __name__ == "__main__":
    run()

