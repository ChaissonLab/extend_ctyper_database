#!/usr/bin/env python3

import os
import threading
import argparse
import concurrent.futures
import datetime
import collections as cl
import re
import numpy as np


script_folder = os.path.dirname(os.path.abspath(__file__))
cutoffdistance = 30000

def process_locus2(region, haplopath, folder, outputfile):
	
	newname,  contig, start, end, ifexon, mapinfo = region
	
	if "#" not in contig: 
		haplo = "CHM13_h1" if "NC_0609" in contig else "HG38_h1"
	else:
		haplo = "_h".join(contig.split("#")[:2])
		
	path = haplopath[haplo]
	
	outputfile0 = os.path.join(folder, f"{newname}.fa")
	
	header = ">{}\t{}:{}-{}\t{}\t{}".format(newname, contig, start, end, ifexon, mapinfo)

	if os.path.isfile(path):	
		cmd1 = f'echo "{header}" >> {outputfile} && samtools faidx {path} {contig}:{start}-{end} | tail -n +2 >> {outputfile}'
	
		os.system(cmd1)
	
	return outputfile0


def makenewfasta2(regions, queryfile, outputfile, folder, threads):
	
	haplopath = dict()
	with open(queryfile, mode = 'r') as f:
		for line in f:
			line = line.strip().split()
			haplopath[line[0]] = line[1]
			
	os.system("rm {} || true ".format(outputfile))
	
	alloutputs = []
	
		#with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
			#futures = []
	for region in regions:
		
				# Submit jobs to executor
			process_locus2( region, haplopath, folder, outputfile)
				#futures.append(executor.submit(process_locus2, region, haplopath, folder, outputfile))
			#alloutputs.append(os.path.join(folder, f"{region[0]}.fa"))
			# Wait for all threads to complete
			#concurrent.futures.wait(futures)
		
		
		
def makegraph(fastafile, folder, threads):
	
	os.system("python {}/graphmake.py -i {}  -d {} -t {}".format(script_folder, fastafile, folder, threads))
	
def process_locus(index, line, haplopath, folder, outputfile):
	line = line.strip().split()
	contig = line[0]
	
	if "#" not in contig: 
		haplo = "CHM13_h1" if "NC_0609" in contig else "HG38_h1"
	else:
		haplo = "_h".join(contig.split("#")[:2])
		
	path = haplopath[haplo]
	strd = "-i" if line[1] == "-" else ""
	
	outputfile0 = os.path.join(folder, f"loci_{index}.fa")
	
	
	header = ">loci_{}\t{}:{}-{}{}\t{}".format(index, contig, line[2], line[3], line[1], line[4],line[5])
	
	line[2] = str(int(line[2]) + 1) 
	cmd1 = f'echo "{header}" > {outputfile0} && samtools faidx {path} {contig}:{line[2]}-{line[3]} {strd} | tail -n +2 >> {outputfile0}'
	os.system(cmd1)
	
	return outputfile0


def makenewfasta(locifile, queryfile, outputfile, folder, threads):
	
	
	haplopath = dict()
	with open(queryfile, mode = 'r') as f:
		for line in f:
			line = line.strip().split()
			haplopath[line[0]] = line[1]
			
	os.system("rm {} || true".format(outputfile))
	
	alloutputs = []
	with open(locifile, mode='r') as f:
		with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
			futures = []
			for index, line in enumerate(f, start=1):
				# Submit jobs to executor
				futures.append(executor.submit(process_locus, index, line, haplopath, folder, outputfile))
				alloutputs.append(os.path.join(folder, f"loci_{index}.fa"))
			# Wait for all threads to complete
			concurrent.futures.wait(futures)
			
	for result in alloutputs:
		
		outputfile0 = result
		cmd2 = f"cat {outputfile0} >> {outputfile}"
		os.system(cmd2)
		
		
		
		
		
def findbreaks(inputfile, outputfile):
	
	names = []
	contigs = cl.defaultdict(list)
	name_tocontig = cl.defaultdict(list)
	index = -1
	with open(inputfile, mode = 'r') as f:
		
		for line in f:
			
			if line.startswith(">"):
				
				index += 1
				name, locus = line[1:].split()[:2]
				names.append(name)
				exon = line.split()[-2]
				
				strd = "+"
				contig, region = locus.split(":")
				if region[-1] in ["+","-"]:
					region = region[:-1]
					strd = locus[-1]
					
				region = region.split("-")
				region = [min(int(region[0]), int(region[1])), max(int(region[0]), int(region[1])), strd, index]
				
				contigs[contig].append(region)
				
	pairs = []        
	new_contigs = cl.defaultdict(list)
	for contig, regions in contigs.items():
		
		regions_sort = sorted(regions)
		
		lastend = regions_sort[0]
		
		pairs.append([contig, lastend[2], max(0, lastend[0] - cutoffdistance), lastend[1], names[lastend[-1]] ])
		
		for region in regions_sort[1:]:
			if max(region[0],region[1], lastend[0],lastend[1]) - min(region[0],region[1], lastend[0],lastend[1]) - abs(region[1]-region[0] ) - abs(lastend[1] - lastend[0]) < cutoffdistance:
				
				strd = region[2] if region[1] - region[0] >= lastend[1] - lastend[0] else lastend[2]
				
				pairs.append([contig, strd,min(region[0],region[1], lastend[0],lastend[1]), max(region[0],region[1], lastend[0],lastend[1]), ";".join([names[region[-1]], names[lastend[-1]]])])
				
			lastend = region
			
		pairs.append([contig, lastend[2],  lastend[0], lastend[1] + cutoffdistance, names[lastend[-1]] ])    
		
		
	with open(outputfile, mode = 'w') as w:
		for pair in pairs:
			w.write("{}\t{}\t{}\t{}\t{}\n".format(pair[0],pair[1],pair[2],pair[3],pair[4]))
			
			
	return pairs


def findstartend(cigar_str):
	
	if not cigar_str:
		return 0,0
	
	cigars = re.findall(r'\d+[M=XIHD]', cigar_str)
	
	lastposi=0
	lsize = 0
	rsize = 0
	for i,cigar in enumerate(cigars):
		
		curr_size = int(cigar[:-1])
		char = cigar[-1]
		
		if (char == '=' or char ==  'M' or char == 'I' ) and curr_size>50:
			break
		if char in ['D','H','X','M','=']:
			lsize += curr_size
			
	for i,cigar in enumerate(cigars[::-1]):
		
		curr_size = int(cigar[:-1])
		char = cigar[-1]
		
		if (char == '=' or char ==  'M' or char == 'I' ) and curr_size>50:
			break
		if char in ['D','H','X','M','=']:
			rsize += curr_size
			
	return lsize,rsize


def polishranges(ranges):
	
	if len(ranges) <= 1:
		return [ranges]
	
	size = abs(ranges[0][2] - ranges[0][1])
	lastend = ranges[0][2]
	breaks = set()
	for i,(index,start,end) in enumerate(ranges[1:]):
		gap = abs(start-lastend)
		if gap > size:
			breaks.add(i+1)
			size = end - start
		else:
			size += end - start - gap
		lastend = end
		
	size = abs(ranges[-1][2] - ranges[-1][1])
	lastend = ranges[-1][1]
	
	for i,(index, start,end) in enumerate(ranges[::-1][1:]):
		gap = abs(end-lastend)
		if gap > size:
			breaks.add(len(ranges) - 2 - i)
			size = end - start
		else:
			size += end - start - gap
		lastend = start
		
	eachbreak = []
	allbreaks = []
	for i,x in enumerate(ranges):
		if i in breaks:
			allbreaks.append(eachbreak)
			eachbreak = []
		eachbreak.append(x)
	allbreaks.append(eachbreak)
	
	return allbreaks

		
		
def qposi_togposi(cigar_str, find_qposes):
	
	l = len(find_qposes)
	if l == 0:
		
		return []
	
	allcigars = re.findall(r'[><][^><]+', cigar_str)
	
	curr_rposi = 0
	curr_qposi = 0
	new_rposi = 0
	new_qposi = 0
	
	curr_strd = 1
	curr_strd_str = ">"
	curr_size = 0
	
	find_qposes = find_qposes + [0]
	find_qpos_index = 0
	find_qpos = find_qposes[0]
	find_rposes = []
	
	for cigars in allcigars:
		
		path, cigar  = cigars.split(":")
		
		pathname = "_".join(path.split("_")[:-2])[1:]
		
		if len(find_rposes):
			
			find_rposes.append((pathname,curr_rposi,curr_qposi-1,curr_strd_str ))
			
		curr_strd_str = cigars [0]
		curr_strd = 1 if curr_strd_str  =='>' else -1
		
		curr_rposi,curr_qposi = path.split("_")[-2:]
		
		curr_rposi,curr_qposi = int(curr_rposi), int(curr_qposi)
		
		if len(find_rposes):
			find_rposes.append((pathname,curr_rposi,curr_qposi,curr_strd_str ))
			
		cigars = re.findall(r'\d+[M=XIHD]', cigars)
		
		if cigars[0][-1] == 'H':
			cigars = cigars[1:]
		if cigars[-1][-1] == 'H':
			cigars = cigars[:-1]
			
		new_rposi, new_qposi = curr_rposi,curr_qposi
		
		for cigar in cigars:
			
			curr_size = int(cigar[:-1])
			char = cigar[-1]
			
			if char == '=' or char ==  'M':
				
				new_rposi = curr_rposi + curr_strd * curr_size
				new_qposi = curr_qposi + curr_size
				
			elif char == 'I':
				
				new_qposi = curr_qposi + curr_size 
				
			elif char == 'D' or char == 'H':
				
				new_rposi = curr_rposi + curr_strd * curr_size
				
			elif char == 'X':
				
				new_rposi = curr_rposi + curr_strd * curr_size
				new_qposi = curr_qposi + curr_size
				
			elif char == 'S':
				
				if curr_qposi == 0:
					curr_qposi = curr_size
					
				curr_size = 0
				continue
			
			while find_qpos_index<l and find_qpos <= new_qposi:
				
				if char == '=' or char ==  'M' or char =='X' :
					
					find_rposes.append((pathname, curr_rposi + curr_strd * (find_qpos-curr_qposi), find_qpos, curr_strd_str ))
				else:
					
					find_rposes.append((pathname,curr_rposi, find_qpos, curr_strd_str ))
					
				find_qpos_index += 1
				find_qpos = find_qposes[find_qpos_index]
				
			if find_qpos_index == l:
				
				return find_rposes
			
			curr_size = 0
			curr_rposi = new_rposi
			curr_qposi = new_qposi
			
			
	while find_qpos_index<l:
		
		find_qpos_index += 1
		find_rposes.append((pathname, curr_rposi, find_qpos, curr_strd_str ))
		
	return find_rposes


def gposi_toqposi(cigar_str, find_rposes):
	
	l = len(find_rposes)
	if l == 0:
		
		return []
	
	find_rposes_dict = cl.defaultdict(list)
	for i,x in enumerate(find_rposes):
		find_rposes_dict[x[0]].append(x[1])
		
	allcigars = re.findall(r'[><][^><]+', cigar_str)
	
	find_rposes = find_rposes + [0]
	curr_rposi = 0
	curr_qposi = 0
	new_rposi = 0
	new_qposi = 0
	
	curr_size = 0
	curr_strd = 1
	find_rpos_index = 0
	find_rpos = find_rposes[0]
	find_qposes = []
	
	for cigars in allcigars:
		
		new_strd = 1 if cigars[0]=='>' else -1
		path, cigars  = cigars.split(":")
		
		pathname = "_".join(path.split("_")[:-2])[1:]
		
		new_rposi,new_qposi = path.split("_")[-2:]
		
		new_rposi,new_qposi = int(new_rposi), int(new_qposi)
		
		find_rposes = sorted(find_rposes_dict[pathname])
		if len(find_rposes) == 0:
			continue
		
		rsize = sum([int(x[:-1]) for x in re.findall(r'\d+[M=XHD]', cigars)]+[0])
		qsize = sum([int(x[:-1]) for x in re.findall(r'\d+[M=XI]', cigars)]+[0]) 
		
		if new_strd == 1:
			cigars = re.findall(r'\d+[M=XHDI]', cigars)
			
		else:
			cigars = re.findall(r'\d+[M=XHDI]', cigars)[::-1]
			new_rposi -= sum([int(x[:-1]) for x in cigars if x[-1] in "M=XHD"]+[0])
			new_qposi += sum([int(x[:-1]) for x in cigars if x[-1] in "M=XI"]+[0])
			
			
		while find_rpos_index<l and find_rpos <= new_rposi + (1-curr_strd)-1//2 :
			
			if abs(find_rpos - curr_rposi) < abs(find_rpos - new_rposi):
				find_qposes.append(curr_qposi)
			else:
				find_qposes.append(new_qposi)
				
			find_rpos_index += 1
			find_rpos = find_rposes[find_rpos_index]
			
		if find_rpos_index == l:
			return find_qposes
		
		curr_strd, curr_rposi, curr_qposi = new_strd, new_rposi, new_qposi
		
		
		for cigar in cigars:
			
			curr_size = int(cigar[:-1])
			char = cigar[-1]
			
			if char == '=' or char ==  'M':
				
				new_rposi = curr_rposi + curr_size 
				new_qposi = curr_qposi + curr_size * curr_strd
			elif char == 'I':
				
				new_qposi = curr_qposi + curr_size * curr_strd
				
			elif char == 'D' or char == 'H':
				
				new_rposi = curr_rposi + curr_size 
				
			elif char == 'X':
				
				new_rposi = curr_rposi + curr_size 
				new_qposi = curr_qposi + curr_size * curr_strd
				
				
			elif char == 'S':
				
				if curr_qposi == 0:
					curr_qposi = curr_size 
					
				curr_size = 0
				continue
			
			while find_rpos_index<l and find_rpos <= new_rposi + (1-curr_strd)-1//2 :
				
				
				if char == '=' or char ==  'M' or char =='X' :
					
					find_qposes.append(curr_qposi + curr_strd * (find_rpos-curr_rposi))
				else:
					
					find_qposes.append(curr_qposi)
					
				find_rpos_index += 1
				find_rpos = find_rposes[find_rpos_index]
				
			if find_rpos_index == l:
				return find_qposes
			
			curr_size = 0
			curr_rposi = new_rposi
			curr_qposi = new_qposi
			
			
		while find_rpos_index<l:
			
			find_rpos_index += 1
			find_qposes.append(-1)
			
			
			
			
	return find_qposes


def overlap(x,y):
	
	return max(x[1],x[0],y[1],y[0]) - min(x[1],x[0],y[1],y[0]) - abs(x[1] - x[0]) - abs(y[1]-y[0])

def cigarleftcut(cigars, cutsize, qstart = 0):
	
	curr_strd = 1
	curr_rposi = 0
	curr_qposi = 0
	new_rposi = 0
	new_qposi = 0   
	
	cigarfix = []
	allpaths = []
	for index,cigar in enumerate(cigars):
		
		curr_size = int(cigar[:-1])
		char = cigar[-1]
		
		if char == '=' or char ==  'M':
			new_rposi = curr_rposi + curr_size
			new_qposi = curr_qposi + curr_size
		elif char == 'D':
			new_rposi = curr_rposi + curr_size
		elif char == 'X':
			new_rposi = curr_rposi + curr_size
			new_qposi = curr_qposi + curr_size
		elif char == 'I':
			new_qposi = curr_qposi + curr_size
			
		if new_rposi > cutsize:
			cigarfix = ["{}{}".format(new_rposi - cutsize,char)]
			if new_qposi > curr_qposi:
				curr_qposi += cutsize - curr_rposi
			break
		
		curr_qposi = new_qposi
		curr_rposi = new_rposi
		
	if curr_qposi > 0:
		cigarfix = ["{}I".format(curr_qposi)] + cigarfix
	newcigars = cigarfix+cigars[index:]
	
	return newcigars

def connectbreaks(cigars,pathes,qposis,rposis):
	
	lastcigar = ""
	lastrposi = (0,0)
	lastqposi = (0,0)
	lastpath = ""
	
	newcigars = []
	newpathes = []
	newqposis = []
	newrposis = []
	for cigar,path,qposi, rposi in zip(cigars,pathes,qposis,rposis):
		
		if path[0] == ">":
			rgap = rposi[0] - lastrposi[1]
		else:
			rgap = lastrposi[0] - rposi[1]
			
		if path == lastpath and abs( rgap ) <1000 and abs(qposi[0] - lastqposi[1]) < 1000:
			
			if rgap > 0:
				cigarfix = "{}D".format(abs(rgap))
				cigar = [cigarfix] + cigar
			elif rgap < 0:
				cigarfix = "{}I".format(abs(rgap))
				cigar = cigarleftcut(cigar, abs(rgap))
				cigar = [cigarfix] + cigar
			newcigars[-1].extend(cigar)
			
			newqposis[-1] = (newqposis[-1][0],qposi[1])
			if path[0] == ">":
				newrposis[-1] = (newrposis[-1][0],rposi[1])
			else:
				newrposis[-1] = (rposi[0], newrposis[-1][1])
		else:
			newcigars.append(cigar)
			newpathes.append(path)
			newqposis.append(qposi)
			newrposis.append(rposi)
			
		lastpath = path
		lastqposi = qposi
		lastrposi = rposi
		
	for i,(cigar,path,qposi, rposi) in enumerate(zip(newcigars,newpathes,newqposis,newrposis)):
		
		leftH,rightH = "",""
		
		length = int(path.split("_")[-1]) - int(path.split("_")[-2])
		
		if path[0] == '>':
			if rposi[0] > 0:
				leftH = "{}H".format(rposi[0])
			if length -rposi[1] > 0:
				rightH = "{}H".format(length - rposi[1])
		else:
			if rposi[0] > 0:
				rightH = "{}H".format(rposi[0])
			if length - rposi[1] > 0:
				leftH = "{}H".format(length - rposi[1])
				
		newcigars[i] = [leftH] + cigar + [rightH]
		
	return newcigars, newpathes, newqposis, newrposis


	
def getspan_ongraph(pathes, cigars):
	qposi = 0 
	qposis = []
	rposis = []
	newcigars = []
	for pathname, cigar in zip(pathes,cigars):
		
		cigar0 = re.findall(r'\d+[M=XHDI]', cigar)
		
		gstart,gend = 0,0
		if cigar0[0][-1] == 'H':
			gstart = int(cigar0[0][:-1])
			cigar0 = cigar0[1:]
		if cigar0[-1][-1] == 'H':
			gend = int(cigar0[-1][:-1])
			cigar0 = cigar0[:-1]
			
		if cigar[0]=='>':
			gend = gstart + sum([int(x[:-1]) for x in cigar0 if x[-1] in "M=XI"]+[0])
		else:
			gstart = gend
			gend = gstart + sum([int(x[:-1]) for x in cigar0 if x[-1] in "M=XI"]+[0])
			
		newcigars.append(cigar0)
		rposis.append((gstart,gend))
		
		qposi_new = qposi + sum([int(x[:-1]) for x in cigar0 if x[-1] in "M=XI"]+[0])
		qposis.append((qposi, qposi_new))
		
		qposi = qposi_new
		
	cigars,pathes,qposis,rposis = connectbreaks(newcigars,pathes,qposis,rposis)
	
	newcigars= "".join(["{}_{}_{}:{}".format(thename,rposi[0],qposi[0],"".join(cigarstr)) if thename[0] == '>' else "{}_{}_{}:{}".format(thename,rposi[1],qposi[0],"".join(cigarstr)) for thename,cigarstr,rposi,qposi in zip(pathes,cigars,rposis, qposis)])
	
	return "".join(newcigars), rposis, qposis

def readlineargraph(linearfile):
	
	contigspan = dict()
	pathsize = dict()
	graphinfo = dict()
	with open(linearfile, mode = 'r') as f:
		
		for line in f:
			
			if len(line.strip()) == 0 or len(line.strip().split()) < 2:
				continue
			
			line = line.strip().split()
			name, path, cigar, gregion, qregion = line
			
			cigar = cigar.translate(str.maketrans('', '', 'ATCGatcgNn-'))
			
			cigars = re.findall(r'[><][^><]+', cigar)
			pathes = re.findall(r'[><][^<>]+',path)
			
	
			graphinfo[name],gregions, qregions  = getspan_ongraph(pathes, cigars)
			
			
			
			
			span = list(zip(pathes, [tuple([int(a) for a in x]) for x in gregions], [tuple([int(a) for a in x]) for x in qregions]))
			
			
			span = [x if x[0][0] =='>' else tuple([x[0],x[1],sorted(x[2],reverse = 1)])  for x in span]
			
			
			
			contigspan[name] = span
			
	return graphinfo, contigspan


def readcontigsinfo(inputfile, breakfile):
	
	genetoscaff = dict()
	with open(inputfile, mode = 'r') as f:
		for line in f:
			if line.startswith(">"):
				line = line.strip().split() + ["",""]
				name = line[0][1:]
				locus = line[1]
				strd = locus[-1]
				contig, coordi = locus.split(":")
				if coordi[-1] in ['-','+']:
					coordi = coordi[:-1]
					
				start, end = map(int, coordi.split("-"))
				start, end = min(start,end), max(start,end)
				genetoscaff[name] = [contig, strd, start, end, line[2], line[3]]
				
				
	locuslocations = dict()
	genetolocus = cl.defaultdict(list)
	
	with open(breakfile, mode = 'r') as f:
		
		scarf_index = 0
		lastend = -10000
		laststart = -10000
		lastcontig = ""
		lastgenes = set()
		for index, line in enumerate(f):
			
			if line.startswith('>') == False:
				continue
			
			line = line.strip().split()
			locusname, region = line[0][1:], line[1]
			
			contig, region = region.split(":")
			
			strd, start, end = region[-1], region[:-1].split("-")[0], region[:-1].split("-")[1]
			
			start, end = min(int(start), int(end)), max(int(start), int(end))
			
			if start > lastend or contig != lastcontig:
				scarf_index += 1
			lastcontig = contig
			lastend = end
			
			names = line[-1].split(";")
			
			lastgenes = set(names)
			
			if len(names) == 1:
				pass 
				
			if "NC_0609" in contig:
				locusname = "Ref_"+locusname
				
			locuslocations[locusname ] = [contig+"_"+str(scarf_index), strd, start, end]
			
			for name in names:
				if strd == '+':
					qstart = genetoscaff[name][2] - start
					qend = genetoscaff[name][3] - start
				else:
					qstart = end - genetoscaff[name][3]
					qend = end  - genetoscaff[name][2]
					qstart,qend = min(qstart,qend), max(qstart,qend)
					
				genetolocus[name].append([locusname, qstart, qend] )
				
				genetoscaff[name][0] = contig+"_"+str(scarf_index)
				
			genetoscaff[locusname] = [contig+"_"+str(scarf_index), strd, start, end]
			
			
	return genetoscaff, genetolocus, locuslocations

def combinebreaks_eachpath(names, breaks):
	
	all_coordinates = breaks
	
	sort_index = sorted(range(len(all_coordinates)), key = lambda x: all_coordinates[x])
	
	break_groups = []
	break_group = []
	
	break_group_index = set([])
	break_group_indexs = []
	
	last_coordinate = 0
	for index in sort_index:
		
		coordinate = all_coordinates[index]
		
		if coordinate - last_coordinate < 100:
			
			break_group.append(coordinate)
			break_group_index.add(names[index//2])
			
		else:
			
			break_groups.append(break_group)
			break_group_indexs.append(break_group_index)
			
			break_group = [coordinate]
			break_group_index = set([names[index//2]])
			
		last_coordinate = coordinate
		
	break_groups.append(break_group)
	break_group_indexs.append(break_group_index)
	
	extendgroup = cl.defaultdict(set)
	
	break_count = cl.defaultdict(int)
	break_uniformed = dict()
	break_tocontignames = cl.defaultdict(set)
	for group,names in zip(break_groups,break_group_indexs):
		
		if len(group) == 0:
			continue
		themedian = int(np.median(group))
		break_tocontignames[themedian] = names
		
		for coordi in group:
			break_uniformed[coordi] = themedian
			
	return break_uniformed, break_tocontignames

	
def combinebreaks(gbreaks):
	
	coordi_onpath = cl.defaultdict(list)
	name_onpath = cl.defaultdict(list)
	for name, breaks in gbreaks.items():
		
		breaks = [ x for y in breaks for x in y]

		for (path, gcoordi, pcoordi, strd,  genename) in breaks:

			coordi_onpath[path].append(gcoordi)
			name_onpath[path].append(name)
			
	break_uniformed_new = dict()
	for path, breaks in coordi_onpath.items():
		
		break_uniformed, break_tocontignames = combinebreaks_eachpath(name_onpath[path], breaks)
		
		for posi0, posi1 in break_uniformed.items():
			
			break_uniformed_new[(path,posi0)] = posi1
			
	return break_uniformed_new



def findvalidbreaks(break_contignames, contigspans):
	
	allcontigs_spans = [z  for y in contigspans.values() for x in y for z in [x[0]-10,x[1]+10]]
	
	allnames =  [z  for name, y in contigspans.items() for x in y for z in [name,name]] 
	
	l1 =  len(allcontigs_spans)
	
	allcoordis = allcontigs_spans+ list(break_contignames.keys())
	
	allcoordis_sort = sorted(list(range(len(allcoordis))), key = lambda x: allcoordis[x])
	
	locus_span = 0
	segment_span = 0
	
	locus_lastposi = cl.defaultdict(int)
	
	allbreaks_found = []
	current_names = set()
	lastbreak = 0
	
	breaks_allspancontigs = cl.defaultdict(list)
	for sortindex, index in enumerate(allcoordis_sort):
		
		if index < l1:
			if index % 2 == 0:
				segment_span += 1
				current_names.add(allnames[index])
			else:
				segment_span -= 1
				try:
					current_names.remove(allnames[index])
				except:
					pass
					
		else:
			coordi = allcoordis[index]
			common = break_contignames[coordi] & set(current_names)
			uncommon = set(current_names) ^ common
			breaks_allspancontigs[coordi].extend(current_names)
			
			totalbreak = len(common)
			totalcontigs = len(current_names)
			
			ifref1,ifref2 = any(x for x in common if x.startswith('Ref_')), any(x for x in uncommon if x.startswith('Ref_'))
			ifref = 10
			if ifref1 and not ifref2 :
				ifref = 1
				
			elif ifref2 and not ifref1:
				ifref = -1
			else:
				ifref = 0
				
				
			allbreaks_found.append([coordi,totalbreak, totalcontigs, ifref, uncommon , common]) 
			
			
			
	locus_addbreaks = cl.defaultdict(set)
	locus_removebreaks = cl.defaultdict(set)
	
	refbreaks = dict()
	novelbreaks = set()
	
	for abreak in allbreaks_found:
		
		coordi, totalbreak, totalcontigs, ifref, uncommon, common = abreak
		
		#mindis = min([abs(x-coordi) for x in existingbreak]+[10000000])
		ifuse = 0 
		
		if ifref == 1:
			refbreaks[coordi] = 1
			
		elif ifref == -1:
			refbreaks[coordi] = -1
			
		elif ifref == 0:
			refbreaks[coordi] = 0
			
			
		elif totalbreak > 0.5*totalcontigs:
			novelbreaks.add((totalbreak, coordi))
			
	return refbreaks, novelbreaks, breaks_allspancontigs


class graphDB:
	
	def __init__(self, break_uniformed):
		
		self.breaks = cl.defaultdict(list)
		self.blocks = cl.defaultdict(list)
		self.blocksize = cl.defaultdict(list)
		self.blockset = cl.defaultdict(set)
		self.allgenes = cl.defaultdict(list)
		self.break_uniformed = break_uniformed
		self.largechunks = set()
		
	def load_refbreaks(self, refbreaks):
		
		refbreaks = [(x[0],self.break_uniformed.get( (x[0],x[1]), x[1] ) ) for x in refbreaks]
		
		for abreak in refbreaks:
			
			self.breaks[abreak[0]].append(abreak[1])
			
		for path, breaks in self.breaks.items():
			
			self.breaks[path] = sorted(list(set(breaks)))
			
	def load_refchunks(self):
		
		index_offsite = 0
		for path, breaks in self.breaks.items():
			
			size = int(path.split('_')[-1]) - int(path.split('_')[-2])
			
			breaks = [0]+breaks+[size+1]
			
			blocks = [(i+index_offsite, path, breaks[i], breaks[i+1]) for i in range(len(breaks)-1) if breaks[i+1] - breaks[i] > 100]
			
			self.blocks[path].extend(blocks)
			
			for i, block in enumerate(blocks):
				self.blockset[tuple([block[1],block[2],block[3]])] = i+index_offsite
				self.blocksize[i+index_offsite] = block[3] -  block[2]
			index_offsite += len(blocks)
			
		return self
	
	def overlap_chunks(self, chunks):
		
		chunks = sorted(chunks, key = lambda x: x[3] + x[4])
		chunks_new = []
		for chunk in chunks:
			
			
			block_index = self.blockset.get(tuple(chunk[:3]),-1)
			
			if block_index == -1:
				
				overlaps = []
				for block,index in self.blockset.items():
					
					if block[0] != chunk[0]:
						continue
					
					overlap = abs(block[2] - block[1]) + abs(chunk[2]-chunk[1]) - max(block[2], block[1], chunk[2], chunk[1]) + min(block[2], block[1], chunk[2], chunk[1])
					
					if overlap > 0.5 * max(abs(block[2] - block[1]),abs(chunk[2]-chunk[1])):
						
						overlaps.append((overlap, index))
						
				overlaps = sorted(overlaps, reverse = 1)
				
				if len(overlaps) and overlaps[0][0] > 100:
					block_index = overlaps[0][1]
					
			chunks_new.append([block_index] + chunk)
			
		return chunks_new
	
	def load_refgenes(self, loci):
		
		def cutspan_bybreaks(spans_flat, breaks):
			
			path_spans = cl.defaultdict(list)
			for (path, gposi, qposi, strd) in spans_flat:
				
				path_spans[path].append((self.break_uniformed.get((path,gposi), gposi),qposi,strd))
				
				
			allchunks = []
			for path, spans_onpath in path_spans.items():
				
				breaks_onpath = breaks[path]
				
				spans_onpath = [sorted([spans_onpath[2*i],spans_onpath[2*i+1]], key = lambda x: x[0]) for i in range(len(spans_onpath)//2)]
				spans_onpath = [(x[0],x[1],y[0][2]) for y in spans_onpath for x in y]
				
				allgcoordis = [x[0] for x in spans_onpath]
				allqcoordis = [(x[1],1 if x[2] == '>' else -1) for x in spans_onpath]
				
				l1 = len(allgcoordis)
				
				allgcoordis =  allgcoordis  + breaks_onpath
				allgcoordis_sortindex = sorted(list(range(len(allgcoordis))), key = lambda x: allgcoordis[x])
				
				current_segs = []
				
				lastqposi = cl.defaultdict(list)
				lastbreak = cl.defaultdict(int)
				for x in allgcoordis_sortindex:
					
					coordi = allgcoordis[x]
					if x < l1:
						if x %2 == 0:
							current_segs.append(x//2)
							lastbreak[x//2] = coordi
							lastqposi[x//2] = allqcoordis[x]
						else:
							allchunks.append([path, lastbreak[x//2], coordi, lastqposi[x//2][0], allqcoordis[x][0]])
							
							current_segs.remove(x//2)
					else:
						for breakindex in current_segs:
							qposi = lastqposi[breakindex][0] + lastqposi[breakindex][1]  * (coordi - lastbreak[breakindex] )
							
							allchunks.append([path, lastbreak[breakindex], coordi, lastqposi[breakindex][0], qposi])
							lastbreak[breakindex] = coordi
							lastqposi[breakindex] = [qposi, lastqposi[breakindex][1]]
							
							
			chunks = sorted([x for x in allchunks if x[2] - x[1] > 100], key = lambda x: x[3])
			
			return chunks
		
		self.genechunks = cl.defaultdict(list)
		self.genechunks_index = cl.defaultdict(list)
		self.chunkindex_togene = cl.defaultdict(set)
		for genes, spans in loci:
			
			for gene in genes:
				
				genename = gene[0][-1]
				
				gene = [tuple([x[0],x[1],x[2],x[3]]) for x in gene]
				
				chunks = cutspan_bybreaks(gene, self.breaks)
				
				chunks = [x for x in chunks if abs(x[2] - x[1]) > 100]
				
				chunks_new = self.overlap_chunks( chunks)
				
				self.genechunks[genename] = chunks_new
				
				self.genechunks_index[tuple([x[0] for x in chunks_new if x[0] >=0 ])].append(genename)
				self.genechunks_index[tuple([x[0] for x in chunks_new[::-1] if x[0] >=0 ])].append(genename)
				
				for i,x in enumerate(chunks_new):
					self.chunkindex_togene[x[0]].add((tuple([x[0] for x in chunks_new if x[0] >=0 ]), i))
					self.chunkindex_togene[x[0]].add((tuple([x[0] for x in chunks_new[::-1] if x[0] >=0 ]), len(chunks_new)-1-i))
					
		self.genes = list(self.genechunks_index.keys())
		self.genenum = len(self.genechunks_index)
		
		return self
	
	def getchunks_fromspan(self, spans):
		
		allchunks = []
	
		path_spans = cl.defaultdict(list)
		
		for (path, grange, qrange) in spans:
			
			path_spans[path[1:]].append([grange, qrange, path[0]])
			
		for path, spans_onpath in path_spans.items():
			
			breaks_onpath = self.breaks[path]
			
			#allgcoordis = [self.break_uniformed.get((path, x),x) for y in spans_onpath for x in y[0]]
			allgcoordis = [[ self.break_uniformed.get((path, x),x)  for x in y[0]] for y in spans_onpath]
			allgcoordis = [[min(x),max(x)] for x in allgcoordis]
			allgcoordis = [x for y in allgcoordis for x in y]


			allqcoordis = [[x,1 if y[2] == '>' else -1] for y in spans_onpath for x in y[1] ]
			
			
			l1 = len(allgcoordis)
		
			allgcoordis = allgcoordis + breaks_onpath
			allgcoordis_sortindex = sorted(list(range(len(allgcoordis))), key = lambda x: allgcoordis[x])
			
			current_segs = []
			lastqposi = cl.defaultdict(list)
			lastbreak = cl.defaultdict(int)
			for x in allgcoordis_sortindex:
				coordi = allgcoordis[x]
				if x < l1:
					if x %2 == 0:
						current_segs.append(x//2)
						lastbreak[x//2] = coordi
						lastqposi[x//2] = allqcoordis[x]
					else:
						allchunks.append([path, lastbreak[x//2], coordi, lastqposi[x//2][0], allqcoordis[x][0]])
						
						#print("atype",[path, lastbreak[x//2], coordi, lastqposi[x//2][0], allqcoordis[x][0]])
						
						current_segs.remove(x//2)
				else:
					for breakindex in current_segs:
						qposi = lastqposi[breakindex][0] + lastqposi[breakindex][1]  * (coordi - lastbreak[breakindex] )
						
						allchunks.append([path, lastbreak[breakindex], coordi, lastqposi[breakindex][0], qposi])
						#print("loop",breakindex,[path, lastbreak[breakindex], coordi, lastqposi[breakindex][0], qposi])
						lastbreak[breakindex] = coordi
						lastqposi[breakindex] = [qposi, lastqposi[breakindex][1]]
						
						
						
						
		allchunks = sorted([x[:3]+sorted(x[3:]) for x in allchunks if abs(x[2] - x[1]) > 100], key = lambda x: x[3]+x[4])
		
		allchunks_index = self.overlap_chunks(allchunks)
		
		return allchunks_index
	
	def update_database(self, allchunks, usedchunks, results):
		
		index_tochunkindex = dict()
		
		newchunks = []
		for i,chunk in enumerate(allchunks):
			if chunk[0] == -1:
				
				findoverlap = 0
				for pastnewchunk in newchunks:
					overlap =  abs(chunk[3]-chunk[2]) +  abs(pastnewchunk[3]-pastnewchunk[2])  - max(pastnewchunk[3], pastnewchunk[2], chunk[3] , chunk[2]) + min(pastnewchunk[3], pastnewchunk[2], chunk[3] , chunk[2])
					if overlap > 0.5 * max(abs(chunk[3]-chunk[2]),abs(pastnewchunk[3]-pastnewchunk[2])):
						newindex = chunk[0]
						findoverlap = 1
						break
					
				if findoverlap == 0:
					newindex = len(self.blockset)
					self.blocks[chunk[1]].append([chunk[2],chunk[3]])
					self.blockset[(chunk[1],chunk[2],chunk[3])] = newindex
					self.blocksize[newindex] = abs(chunk[3] - chunk[2])
					index_tochunkindex[i] = newindex
					chunk[0] = newindex
					newchunks.append(chunk)
				else:
					index_tochunkindex[i] = newindex
					chunk[0] = newindex
					
		novels = []
		novel = []
		lastqend = -1000000
		for i,x in enumerate(allchunks):
			if i == -1:
				qstart,qend = x[4],x[5]
				if abs(qstart - lastqend) < 30000:
					novel.append([i,qstart,qend])
				else:
					if len(novel):
						novels.append(novel)
					novel = [[i,qstart,qend]]
				lastqend = qend
				
		if len(novel):
			novels.append(novel)
			
		novels = [x for y in novels for x in polishranges(y) if len(x)]
		
		for result in results:
			chunks_new = tuple([index_tochunkindex.get(x,y) for x,y in zip(result[0],result[1])])
			if chunks_new in self.genechunks_index or len(chunks_new) <= 1:
				continue
			
			genename = "New_"+str(len(self.genechunks))
			
			self.genechunks[genename] = chunks_new
			self.genechunks_index[chunks_new].append(genename)
			self.genechunks_index[chunks_new[::-1]].append(genename)
			
			for i,x in enumerate(chunks_new):
				self.chunkindex_togene[x].add((chunks_new, i))
				self.chunkindex_togene[x].add((chunks_new[::-1], len(chunks_new)-1-i))
				
		for chunks_new in novels:
			
			chunks_new = [x[0] for x in chunks_new]
			chunks_new = tuple(range(min(chunks_new),max(chunks_new)+1))
			
			if chunks_new in self.genechunks_index or len(chunks_new) <= 1:
				continue
			
			genename = "Novel_"+str(len(self.genechunks))
			
			self.genechunks[genename] = chunks_new
			self.genechunks_index[chunks_new].append(genename)
			self.genechunks_index[chunks_new[::-1]].append(genename)
			
			for i,x in enumerate(chunks_new):
				self.chunkindex_togene[x].add((chunks_new, i))
				self.chunkindex_togene[x].add((chunks_new[::-1], len(chunks_new)-1-i))
				
		self.genes = set(list(self.genechunks_index.keys()))
		self.genenum = len(self.genechunks_index)
		
	def assemblysmall(self,results):
		
		def ifalign(thelist,x):
			
			l = len(x)
			for i in range(len(thelist)):
				
				if x == thelist[i:(i+l)]:
					
					return 1
			
			return 0
		
		
		for result in results[:-1]:
			
			size = abs(result[4] - result[3])
			if size > 10000:
				self.largechunks.update(result[1])
				
		newresults = []
		for result in results[:-1]:
			
			size = abs(result[4] - result[3])
			
			alignref = 0
			if len(newresults):
			
				combined = newresults[-1][1] + result[1]
				for gene in self.genes:
					
					gene = list(gene)
					if ifalign(gene, combined):
						alignref = 1
						break
			
			if alignref or (size > 500 and size < 10000 and len(newresults) and len(self.largechunks & set(result[1]) )):
					
				newresults[-1][0].extend(result[0])
				newresults[-1][1].extend(result[1])
				newresults[-1][4] = result[4]
				newresults[-1][5].extend(result[5])
				
			else:
				newresults.append(result)
		
		for result in newresults:
			self.genes.add(tuple(result[1]))
				
		return newresults

	def overlap_genes(self, spans, ifupdate = 0):
		
		def determinegenes(allchunks,passed_genes):
			
			passed_genes = sorted([x for x in passed_genes if len(x[2])], key = lambda x: max( [  y[2] for y in x[2] ] ), reverse =1 )
			
			
			selected_genes = []
			exclude = set()
			for gene in passed_genes:
				
				chunk_usedindex = list(range(min(gene[0]),max(gene[0])+1))
				
				
				if exclude & set(chunk_usedindex):
					continue
				
				selected_genes.append(gene)
				
				if len(gene[0]):
					exclude.update(chunk_usedindex)
					
			for ichunk, chunk in enumerate(allchunks):
				
				chunkindex = chunk[0]
				qstart,qend = chunk[4],chunk[5]
				
				if chunkindex  >= 0 and ichunk not in exclude:
					
					gene = [[ichunk], [chunkindex], [], qstart, qend , [ [qstart, qend]]]
					selected_genes.append(gene)
					
			return selected_genes,exclude
		
		def extendgenes(current_genes, passed_genes, ichunk, chunkindex, qstart, qend, ifupdate = 1):
			
			current_genes = sorted(current_genes, key = lambda x: len(x[1]), reverse =1 )
			
			continued_genes = []
			
			mingap = 1000000000
			ifmatch = 0
			for index,gene in enumerate(current_genes):
				
				insersize = qstart - gene[4]
				
				if insersize > 30000:
					passed_genes.append(gene)
					continue
				
				involves = gene[2]
				
				involves_new = []
				for (involvegene, aligns, score) in involves:
					
					alignindex = aligns[-1]
					
					if chunkindex in involvegene[(alignindex+1):]:
						
						newindex = alignindex+1 +involvegene[(alignindex+1):].index(chunkindex)
						
						delsize = sum([self.blocksize[involvegene[x]] for x in range(alignindex+1, newindex)])
						
						newscore = qend - qstart - 2*insersize - 2*delsize
						
						score += newscore
						
						mingap = min(mingap, insersize+delsize)
												
						if delsize < 30000 and newscore >= 0:
							involves_new.append((involvegene, aligns+[newindex], score))
							
				if len(involves_new):
					
					if not ifupdate:
						gene_old = [x if type(x) != type([]) else [y for y in x] for x in gene]
						continued_genes.append(gene_old)
					
					gene[0].append(ichunk)
					gene[1].append(chunkindex)
					gene[2] = involves_new
					gene[4] = qend
					gene[5].append([qstart, qend])
					continued_genes.append(gene)
					
				elif len(gene[0]) >0:
					
					if ifupdate:
						continued_genes.append(gene)
					else:
						passed_genes.append(gene)
				
				
			return continued_genes, mingap
		
		current_genes = cl.defaultdict(list)
		passed_genes = []
		allchunks = self.getchunks_fromspan(spans)
		allchunks = sorted(allchunks, key = lambda x: x[4] + x[5])
		
		lastchunk = -100000
		for ichunk, chunk in enumerate(allchunks):
			
			chunkindex = chunk[0]
			qstart,qend = chunk[4],chunk[5]
			
			allinvolve_genes = self.chunkindex_togene.get(chunkindex,[])
			
			if len(allinvolve_genes) == 0 and len(current_genes) == 0:
				continue
			
			continued_genes, mingap = extendgenes(current_genes, passed_genes, ichunk, chunkindex, qstart, qend, ifupdate)
			
			current_genes = continued_genes
			
			new_gene = [[ichunk], [chunkindex], [], qstart, qend , [ [qstart, qend]]]
			
			allinvolve_genes = self.chunkindex_togene.get(chunkindex,[])
			for (gene,alignindex) in allinvolve_genes:
				
				new_gene[2].append((gene,[alignindex],qend - qstart))
				
			current_genes.append(new_gene)
			
		passed_genes.extend(current_genes)
				
		results, used_chunks = determinegenes(allchunks,passed_genes)
		
		
		for result in results:
			result[2] = [(x[2],self.genechunks_index.get(x[0], [""])[0]) for x in result[2]]
			if len(result[2]):
				result[2] = result[2][0]
				
		results = sorted(results, key = lambda x: tuple(x[0]))
		
		if ifupdate:
			self.update_database(allchunks, used_chunks, results)
		
		
		
			
		return results 


	
	
	
	
	
	
def getblocks(gbreaks, break_uniformed, contigspans, genetoscaff, graphinfo):
	
	allloci = [x for x in gbreaks.keys() if x.startswith("Ref_")] + [x for x in gbreaks.keys() if not x.startswith("Ref_")]
	
	thegraph = graphDB(break_uniformed)
	
	refgenes = []
	for name, gbreak in gbreaks.items():
		
		if name.startswith("Ref_"):
			
			thegraph.load_refbreaks([(x[0],x[1]) for y in gbreak for x in y])
			
			refgenes.append([gbreaks[name], contigspans[name]])
			
	thegraph.load_refchunks().load_refgenes(refgenes)
	
	results = dict()
	for loci in allloci:
		results[loci] = thegraph.overlap_genes(contigspans[loci], ifupdate=1)
		
	for loci in allloci:
		
		result = thegraph.overlap_genes(contigspans[loci])
	
		results[loci] = thegraph.assemblysmall(result )
		
	return results


def breaks_ongraph(genetoscaff, genetolocus, graphinfo, contigspan):
	
	gbreaks = cl.defaultdict(list)
	
	segmentinfo =  cl.defaultdict(list)
	for name, infos in genetolocus.items():
		
		for info in infos:
			
			locus,start,end = info
			
			if locus.startswith("Ref_"):
				graphinfo[locus] = graphinfo[locus[4:]]
				
				if locus[4:] in contigspan:
					contigspan[locus] = contigspan[locus[4:]]
					del contigspan[locus[4:]]
					
			coordinates = qposi_togposi(graphinfo[locus], [start,end-1])
			
			gbreaks[locus].append([list(x)+[name] for x in coordinates])
			
			segmentinfo[locus].append([coordinates[0],coordinates[1], name])
			
	gbreaks = {locus:sorted(regions, key = lambda x: x[0][2]) for locus, regions in gbreaks.items() }

	breaks_andspans = cl.defaultdict(list)
	for name, data in gbreaks.items():
		breaks_andspans[name] = [x for x in data]
	for name, data in contigspan.items():
		breaks_andspans[name].append([[x[0][1:],x[1][y],x[2][y],x[0][0],""] for x in data for y in [0, 1]])

	break_uniformed = combinebreaks(breaks_andspans)

	results = getblocks(gbreaks, break_uniformed, contigspan, genetoscaff, graphinfo)
	
	return results

def annotate_regions(breaksoncontigs, locuslocations, genetoscaff):
	
	groupprefix = ""
	geneoncontigs = cl.defaultdict(list)
	for genename, info in genetoscaff.items():
		
		if len(info) > 4:
			geneoncontigs[info[0]].append(info[2:]+[genename])
			groupprefix = genename.split('_')[0]   
			
	novel_overlap = [x[2][1]  for loci, breaks in breaksoncontigs.items() for x in breaks if len(x[2]) ]
	novel_overlap = list(set(novel_overlap))
	
	genelabs = dict()
	regions = []
	for loci, breaks in breaksoncontigs.items():
		
		
		scaflocus = locuslocations[loci]
		
		lastend = 0
		for segments in breaks:
			
			for i,segment in enumerate(segments[5]):
				
				start,end = min(segment[0],segment[1]),max(segment[0],segment[1])
				
				if segment[0] < max(start,lastend):
					segment[0] = max(start,lastend)
				if segment[1] < max(end,lastend):
					segment[0] = max(end,lastend)
					
				lastend = max(end,lastend)
				
		oldsegments = geneoncontigs[scaflocus[0]]
		
		for segment in breaks:
			
			start, end = segment[5][0][0], segment[5][-1][1]
			
			if scaflocus[1] == '+':
				scafstart = scaflocus[2] + start
				scafend = scaflocus[2] + end
			else:
				scafstart = scaflocus[3] - end
				scafend = scaflocus[3] - start
				
			genelab = segment[2]
			
			
			
			overlap = []
			if len(genelab) == 0 or genelab[1] not in genelabs:
				
				overlap = sorted([( (x[1] - x[0]) + (scafend - scafstart) - max(x[1],scafend,x[0],scafstart) + min(x[1],scafend,x[0],scafstart), x) for i,x in enumerate(oldsegments)], reverse=1)[0]
				if len(genelab):
					genelabs[genelab[1]] = overlap
					
			elif len(genelab):
				overlap = genelabs[genelab[1]]
				
			if len(overlap) and overlap[0] > 1000:
				regions.append([scaflocus[0], scafstart, scafend] + overlap[1][2:])
				
			else:
				pass
				#regions.append([scaflocus[0], scafstart, scafend] + ["NA","NA","NA"])
	
	new_regions = cl.defaultdict(list)
	haplo_counter = cl.defaultdict(int)
	for region in regions:
		
		contig, start, end, ifexon, mapinfo,oldname = region
		
		haplo = "_h".join(contig.split("#")[:2]) if "#" in contig else "CHM13_h1" if "NC_0609" in contig else "HG38_h1"
		
		haplo_counter[haplo] += 1
		
		newname = groupprefix+"_"+ haplo  +"_"+ str(haplo_counter[haplo])
		
		#header = "{}\t{}:{}-{}\t{}\t{}".format(newname, contig, start, end, ifexon, mapinfo  )
		
		new_regions[contig].append([newname,  contig, start, end, ifexon, mapinfo])
		
		
		
	return new_regions

def coordinate_uniform(cbreaks_sort):
	
	uniform_coordis = []
	
	currbreaks =  []
	lastbreak = -100
	for coordi in cbreaks_sort:
		if (coordi - lastbreak) < 100:
			currbreaks.append(coordi)
		else:
			if len(currbreaks):
				uniform = cl.Counter(currbreaks).most_common(1)[0][0]
				uniform_coordis.extend([uniform] * 1)
				
			currbreaks = [coordi]
			
		lastbreak = coordi
		
	if len(currbreaks):
		uniform = cl.Counter(currbreaks).most_common(1)[0][0]  
		uniform_coordis.extend([uniform] * 1)
		
		
	return uniform_coordis



def locatebreaksoncontigs(breaksonscaf, locuslocations, genetoscaff):
	
	oldbreaksoncontig = cl.defaultdict(list)
	for gene,obreaks in genetoscaff.items():
		
		scaf, strd, start, end = obreaks[:4]
		
		oldbreaksoncontig[scaf].extend([start, end])
		
	results = cl.defaultdict(list)
	for scafford, cbreaks in breaksonscaf.items():
		
		if len(cbreaks) == 0:
			continue
		
		cbreaks_sort_index = sorted(range(len(cbreaks)), key = lambda x: cbreaks[x])
		
		cbreaks_sort = sorted([cbreaks[x] for x in cbreaks_sort_index])
		
		cbreaks_sort_uniform = coordinate_uniform(cbreaks_sort)
		
		oldmin = min(oldbreaksoncontig[scafford]+[-100]) 
		oldmax = max(oldbreaksoncontig[scafford]+[100000000000])
		
		cbreaks_sort_uniform_rangeindex = [i for i,x in enumerate(cbreaks_sort_uniform) if x > oldmin + 100 and x< oldmax-100 ]
		
		if len(cbreaks_sort_uniform_rangeindex) == 0:
			
			if min(cbreaks_sort_uniform_rangeindex) > 0:
				cbreaks_sort_uniform_rangeindex = [min(cbreaks_sort_uniform_rangeindex)-1] + cbreaks_sort_uniform_rangeindex
			if max(cbreaks_sort_uniform_rangeindex) < len(cbreaks_sort_uniform_rangeindex) - 1:
				cbreaks_sort_uniform_rangeindex =  cbreaks_sort_uniform_rangeindex + [max(cbreaks_sort_uniform_rangeindex)+1]
				
		cbreaks_sort_uniform = [cbreaks_sort_uniform[x] for x in cbreaks_sort_uniform_rangeindex]
		
		if len(cbreaks_sort_uniform ) == 0:
			cbreaks_sort_uniform = oldbreaksoncontig[scafford]
		elif  len(cbreaks_sort_uniform ) <= 1 or oldmin < min(cbreaks_sort_uniform) - 1000 or oldmax > max(cbreaks_sort_uniform) + 1000:
			cbreaks_sort_uniform = [x for x in oldbreaksoncontig[scafford] if x < min(cbreaks_sort_uniform) -1000 ] + cbreaks_sort_uniform + [x for x in oldbreaksoncontig[scafford] if x > max(cbreaks_sort_uniform) + 1000 ]
			
			#cbreaks_sort_uniform = sorted(oldbreaksoncontig[scafford])
			
		results[scafford] = cbreaks_sort_uniform 
		
	return results



def uniformbreaks(inputfile, outputfile):
	
	breakfile = outputfile+"_loci.txt"
	graphref = outputfile+"_loci.txt.fasta"
	
	linearfile = outputfile +"_loci.txt.fasta_allgraphalign.out"
	
	genetoscaff, genetolocus, locuslocations = readcontigsinfo(inputfile, graphref)
	
	graphinfo, contigspan = readlineargraph(linearfile)
	
	results = breaks_ongraph(genetoscaff, genetolocus, graphinfo, contigspan)
	
	regions = annotate_regions(results,  locuslocations, genetoscaff)
	
	regions = [x[:1]+["_".join(x[1].split("_")[:-1])]+x[2:] for y in regions.values() for x in y]
	
	return regions

def main(args):
	
	#os.system("python {}/exambreaks.py -i {} -n {} -o {} ".format(script_folder,args.input, args.norm, args.input))
	
	if len(args.folder)==0: 
		folder = args.input +  datetime.datetime.now().strftime("%y%m%d_%H%M%S/").replace("%","_")
		
		os.system("rm -rf {} || true".format(folder))
		#os.system("mkdir {} || true".format(folder))
		
	else:
		folder = args.folder
		#os.system("mkdir {} || true".format(folder))
		
	graphref = args.output+"_loci.txt.fasta"
	
	###pairs = findbreaks(args.input, args.output+"_breaks.txt")
	
	###
	##makenewfasta(args.output+"_breaks.txt", args.query, args.output+"_breaks.txt.fasta", folder ,args.threads)
	
	if len(args.kmer):
		pass
		##os.system("python {}/kmerstrd.py -i {} -k {} -o {}".format(script_folder,graphref, args.kmer, graphref+"_"))
		##os.system("mv {} {} || true".format(graphref+"_", graphref))
		
	##makegraph(args.output+"_breaks.txt.fasta", folder, args.threads)
		
	regions = uniformbreaks(args.input, args.output)
	makenewfasta2(regions, args.query, args.output, folder, args.threads)
	
	if len(args.folder)==0:
		os.system("rm  -rf {} || true".format(folder))
		
	"""
	if len(args.kmer):
		
		os.system("python {}/kmerstrd.py -i {} -k {} -o {}".format(script_folder,args.output, args.kmer, args.output+"_"))
		os.system("mv {} {} || true".format(args.output+"_", args.output))
	
	if len(args.folder)==0:
		os.system("rm  -rf {} || true".format(folder))
	"""
		
		
		
def run():
	"""
		Parse arguments and run
	"""
	parser = argparse.ArgumentParser(description="")
	parser.add_argument("-i", "--input", help="path to input data file",dest="input", type=str, required=True)
	parser.add_argument("-n", "--norm", help="path to input data file",dest="norm", type=str, required="")
	parser.add_argument("-k", "--kmer", help="path to input data file",dest="kmer", type=str, default="")
	parser.add_argument("-o", "--output", help="path to output file", dest="output",type=str, required=True)
	parser.add_argument("-t", "--threads", help="path to output file", dest="threads",type=int, default = 1)
	parser.add_argument("-q", "--query", help="path to output file", dest="query",type=str, default = True)
	parser.add_argument("-d", "--folder", help="path to output file", dest="folder",type=str, default = "")   
	
	parser.set_defaults(func=main)
	args = parser.parse_args()
	args.func(args)
	
	
if __name__ == "__main__":
	run()
