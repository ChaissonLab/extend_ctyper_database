#!/usr/bin/env python3

import os
import argparse
import re
import bisect

def makereverse(seq):
	
	tran=str.maketrans('ATCGatcg', 'TAGCtagc')
	
	return seq[::-1].translate(tran)

def pathtoseq(path, pathstrs):
	
	pathes = re.findall(r'[><]s\d+', path)
	
	fullseq = ""
	for eachpath in pathes:
		
		strd = eachpath[0]
		
		seq = pathstrs[eachpath[1:]]
		
		if strd == "<":
			
			seq = makereverse(seq)
			
		fullseq += seq
		
	return fullseq

def alignregion(allaligns, allow_gap = 0):


	all_coordinates = [x for y in allaligns for x in y[:2]]
	scores = [y[2] for y in allaligns]
	lineindex = [y[3] for y in allaligns]
	
	sort_index = sorted(range(len(all_coordinates)), key = lambda x: all_coordinates[x])
	
	current_alignscores = []
	allgroups = [[0,0,0,0]]
		
	number_curr_seq = 0
	last_coordinate = - allow_gap - 1
	last_index = -2
	last_score = -1
	for index in sort_index:
		
		coordinate = all_coordinates[index]
		score = scores[index//2]


		if index %2 == 0 :

			last_score = current_alignscores[-1][0] if len(current_alignscores) else 0
			if last_index%2 and len(current_alignscores) and coordinate - last_coordinate>allow_gap:

				current_alignscores.remove([scores[last_index//2], last_index//2])

			
			if  len(current_alignscores) == 0  or score > last_score :
				
				if number_curr_seq:
					allgroups[-1][-1] = coordinate
					
				allgroups.append([score, index//2, coordinate, coordinate])
				
				
			bisect.insort(current_alignscores, [score, index//2])
		
	
			number_curr_seq += 1
			
		else:
			
			allgroups[-1][-1] = coordinate
			
			number_curr_seq -= 1
		
		last_index =  index
	
		last_coordinate = coordinate

	allgroups = [x[2:]+allaligns[x[1]][2:]+[lineindex[x[1]]] for x in allgroups[1:]]

	return allgroups

def findaligns(cigars, posi):
	
	cigars = re.findall(r'\d+[a-zA-Z=]', cigars)
	
	newcigars = []
	
	refposi = 0 
	aligns = []
	newref = ""
	for cigar in cigars:
		
		thesize = int(cigar[:-1])
		thetype = cigar[-1]
		
		if thetype == "=" or thetype == "M":
			
			if thesize > 30:
				aligns.append([posi, posi+thesize])
				
			posi += thesize
			refposi += thesize
			
		elif thetype == "X" or thetype == "S":
			
			posi += thesize
			refposi += thesize
			
		elif thetype == "D" or thetype == "H":
			
			refposi += thesize
			
		elif thetype == "I":
			
			posi += thesize
			
	return aligns

def cigaredit(cigars, queryseq, refseq):
	
	cigars = re.findall(r'\d+[a-zA-Z=]', cigars)
	
	refposi = 0
	posi = 0
	newcigars = []
	
	newref = ""
	for cigar in cigars:
		
		thesize = int(cigar[:-1])
		thetype = cigar[-1]
		
		if thetype == "=":
			
			
			matchormismatch = 0
			last_i = 0
			newcigar = []
			for i, (r,q) in enumerate(zip(refseq[refposi:(refposi+thesize)], queryseq[posi:(posi+thesize)])):

				if matchormismatch ==0 and r.upper() != q.upper():

					newcigar.append("={}".format(i-last_i))
					last_i = i
					matchormismatch = 1
					check = 1

				elif matchormismatch ==1 and r.upper() == q.upper():

					newcigar.append("X{}".format(i-last_i))
					last_i = i
					matchormismatch = 0

			i = thesize
			if matchormismatch ==0:
				newcigar.append("={}".format(i-last_i))
			else:
				newcigar.append("X{}".format(i-last_i))

			cigar = "".join(newcigar)
			
			
			newcigars.append(cigar)
			
			newref += refseq[refposi:(refposi+thesize)]
			
			posi += thesize
			
			refposi += thesize
			
			
		elif thetype == "X":
			
			newcigars.append(cigar+queryseq[posi:(posi+thesize)])
			posi += thesize
			
			newref += "X"*thesize
			refposi += thesize
			
		elif thetype == "D":
			
			newcigars.append(cigar)
			
			refposi += thesize
			
		elif thetype == "I":
			
			newcigars.append(cigar+queryseq[posi:(posi+thesize)])
			posi += thesize
			
			newref += "-"*thesize
			
			
	return "".join(newcigars)



def lineartograph(graphfile, queryfile, alignfile, output):
	
	with open(queryfile, mode = 'r') as f:
		reads = [read.splitlines() for read in f.read().split(">")[1:]]
		reads = {read[0].split()[0]:"".join(read[1:]) for read in reads}
		
	with open(graphfile, mode = 'r') as f:
		refs = [read.splitlines() for read in f.read().split(">")[1:]]
		refs = {read[0].split()[0]:"".join(read[1:]) for read in refs}
	
	
	allaligns = []
	with open(alignfile, mode = 'r') as f:
		
		lines = f.read().splitlines()


	for index, line in enumerate(lines):
			
		if len(line) == 0 or line[0]=="@":
			continue
			
		elements = line.strip().split()
			#name, qsize, qstart, qend, path, rsize, rstart, rend = elements[:8]
			
			
		identity =float( [x for i,x in enumerate(elements) if x[:5] == "PI:f:"][0][5:])
		match = int( [x for i,x in enumerate(elements) if x[:5] == "AS:i:"][0][5:] ) 
			
		if identity < 90 or match < 100 or elements[4] != '255':
			continue
			
		strand, qstart, cigar = elements[1], int(elements[3]), elements[5]
		strand = 1 if strand == '0' else -1
			
		aligns = findaligns(cigar, qstart)
			
		allaligns.extend([x+[match, index] for x in aligns])
			
			#newcigar = cigaredit(cigar, queryseq[int(qstart):int(qend)], refseq)
			
			#elements[index] = "{}I{}".format(qstart,queryseq[:int(qstart)])+ newcigar + "{}I{}".format(int(qsize)-int(qend),queryseq[int(qend):])
	
	alignregions = alignregion(allaligns)

	for region in alignregions:

		line = lines [region[0]] 	
		
			
	exit(0)
	
	w= open(output, mode = 'w')
	
	w.write("\t".join(elements)+"\n")
	w.close()
	
def main(args):
	
	lineartograph(args.ref, args.query, args.input, args.output)
	
def run():
	"""
		Parse arguments and run
	"""
	parser = argparse.ArgumentParser(description="program distract overlap genes and alignments on contigs")

	parser.add_argument("-r", "--ref", help="path to output file", dest="ref", type=str,required=True) 
	parser.add_argument("-q", "--query", help="path to output file", dest="query", type=str,required=True) 	
	parser.add_argument("-i", "--input", help="path to output file", dest="input", type=str,required=True)
	parser.add_argument("-o", "--output", help="path to output file", dest="output", type=str,required=True)
	
	parser.set_defaults(func=main)
	args = parser.parse_args()
	args.func(args)
	
	
if __name__ == "__main__":
	run()
